---
title: Dual Authorization
description: Dual Authorization for SSH and Kubernetes.
videoBanner: b_iqJm_o15I
version: "15.x"
---

You can set up Teleport to require the approval of multiple team members to perform some critical actions.
Here are the most common scenarios:

- Improve the security of your system and prevent one successful phishing attack from compromising your system.
- Satisfy FedRAMP AC-3 Dual authorization control that requires approval of two authorized individuals.

In this guide, we will set up Teleport's Just-in-Time Access Requests to require
the approval of two team members for a privileged role `dbadmin`.

The steps below describe how to use Teleport with Mattermost. You can also
[integrate with many other providers](/docs/access-controls/access-requests).

<Warning>
  This guide requires a commercial edition of Teleport. The open source edition of
  Teleport only supports [GitHub](/docs/access-controls/sso/github-sso) as an
  SSO provider.
</Warning>

## Prerequisites

- Mattermost installed.

- Access to an Enterprise edition of Teleport running in your environment.

  For information about the differences between Teleport editions, see [Comparing
  editions](/docs/choose-an-edition/introduction#comparing-editions).

- The Enterprise `tctl` admin tool and `tsh` client tool version >= 15.0.2.

  You can verify the tools you have installed by running the following commands:

  ```bash
  $ tctl version
  # Teleport Enterprise v15.0.2 go1.21

  $ tsh version
  # Teleport v15.0.2 go1.21
  ```

  You can download these tools by following the appropriate [Installation
  instructions](/docs/installation#installation-instructions) for your environment and Teleport edition.

<Tip>
  <p>
    **Running Mattermost locally with Docker**
  </p>

  ```bash
  $ docker run --name mattermost-preview -d --publish 8065:8065 --add-host dockerhost:127.0.0.1 mattermost/mattermost-preview
  ```
</Tip>

- To check that you can connect to your Teleport cluster, sign in with `tsh login`, then
  verify that you can run `tctl` commands using your current credentials.
  `tctl` is supported on macOS and Linux machines.

  For example:
  ```bash
  $ tsh login --proxy=teleport.example.com --user=email@example.com
  $ tctl status
  # Cluster  teleport.example.com
  # Version  15.0.2
  # CA pin   sha256:abdc1245efgh5678abdc1245efgh5678abdc1245efgh5678abdc1245efgh5678
  ```
  If you can connect to the cluster and run the `tctl status` command, you can use your
  current credentials to run subsequent `tctl` commands from your workstation.
  If you host your own Teleport cluster, you can also run `tctl` commands on the computer that
  hosts the Teleport Auth Service for full permissions.

## Step 1/3. Set up a Teleport bot

### Create a bot within Mattermost

Enable bot account creation in "System Console -> Integrations".

Toggle `Enable Bot Account Creation`.

<img src="/assets/mattermost-0-enable-390f27a7ac.png" alt="Enable bots" width="1896" height="970" />

Go back to your team settings, navigate to "Integrations -> Bot Accounts". Press "Add Bot Account".

<img src="/assets/mattermost-1-bot-938870d05a.png" alt="Enable bots" width="1980" height="780" />

Add the "Post All" permission on the new account.

<img src="/assets/mattermost-2-all-permissions@2x-ec6f658606.png" alt="Enable bots" width="649" height="574" />

Create the bot and save the access token.

### Set up RBAC for the plugin

Teleport's Access Request plugins authenticate to your Teleport cluster as a
user with permissions to list and read Access Requests. This way, plugins can
retrieve Access Requests from the Teleport Auth Service and present them to
reviewers.

Define a user and role called `access-plugin` by adding the following content to
a file called `access-plugin.yaml`:

```yaml
kind: role
version: v5
metadata:
  name: access-plugin
spec:
  allow:
    rules:
      - resources: ['access_request']
        verbs: ['list', 'read']
      - resources: ['access_plugin_data']
        verbs: ['update']
---
kind: user
metadata:
  name: access-plugin
spec:
  roles: ['access-plugin']
version: v2
```

Create the user and role:

```bash
$ tctl create -f access-plugin.yaml
```

As with all Teleport users, the Teleport Auth Service authenticates the
`access-plugin` user by issuing short-lived TLS credentials. In this case, we
will need to request the credentials manually by *impersonating* the
`access-plugin` role and user.

If you are running a self-hosted Teleport Enterprise deployment and are using
`tctl` from the Auth Service host, you will already have impersonation
privileges.

To grant your user impersonation privileges for `access-plugin`, define a role
called `access-plugin-impersonator` by pasting the following YAML document into
a file called `access-plugin-impersonator.yaml`:

```yaml
kind: role
version: v5
metadata:
  name: access-plugin-impersonator
spec:
  allow:
    impersonate:
      roles:
      - access-plugin
      users:
      - access-plugin
```

Create the `access-plugin-impersonator` role:

```bash
$ tctl create -f access-plugin-impersonator.yaml
```

If you are providing identity files to the plugin with Machine ID, assign the
`access-plugin` role to the Machine ID bot user. Otherwise, assign this role to
the user you plan to use to generate credentials for the `access-plugin` role
and user:

Assign the `access-plugin-impersonator` role to your Teleport user by running the appropriate
commands for your authentication provider:

<Tabs>
  <Tab title="Local User">
    1. Retrieve your local user's roles as a comma-separated list:

       ```bash
       $ ROLES=$(tsh status -f json | jq -r '.active.roles | join(",")')
       ```

    2. Edit your local user to add the new role:

       ```bash
       $ tctl users update $(tsh status -f json | jq -r '.active.username') \
         --set-roles "${ROLES?},access-plugin-impersonator"
       ```

    3. Sign out of the Teleport cluster and sign in again to assume the new role.
  </Tab>

  <Tab title="GitHub">
    1. Retrieve your `github` authentication connector:

       ```bash
       $ tctl get github/github --with-secrets > github.yaml
       ```

       Note that the `--with-secrets` flag adds the value of `spec.signing_key_pair.private_key`
       to the `github.yaml` file. Because this key contains a sensitive value, you should remove the
       github.yaml file immediately after updating the resource.

    2. Edit `github.yaml`, adding `access-plugin-impersonator` to the `teams_to_roles` section.

       The team you should map to this role depends on how you have designed your
       organization's role-based access controls (RBAC). However, the team must include your user account and
       should be the smallest team possible within your organization.

       Here is an example:

       ```diff
         teams_to_roles:
           - organization: octocats
             team: admins
             roles:
               - access
       +       - access-plugin-impersonator
       ```

    3. Apply your changes:

       ```bash
       $ tctl create -f github.yaml
       ```

    4. Sign out of the Teleport cluster and sign in again to assume the new role.
  </Tab>

  <Tab title="SAML">
    1. Retrieve your `saml`  configuration resource:

       ```bash
       $ tctl get --with-secrets saml/mysaml > saml.yaml
       ```

       Note that the `--with-secrets` flag adds the value of `spec.signing_key_pair.private_key`
       to the `saml.yaml` file. Because this key contains a sensitive value, you should remove the
       saml.yaml file immediately after updating the resource.

    2. Edit `saml.yaml`, adding `access-plugin-impersonator` to the `attributes_to_roles` section.

       The attribute you should map to this role depends on how you have designed your
       organization's role-based access controls (RBAC). However, the group must include your
       user account and should be the smallest group possible within your organization.

       Here is an example:

       ```diff
         attributes_to_roles:
           - name: "groups"
             value: "my-group"
             roles:
               - access
       +       - access-plugin-impersonator
       ```

    3. Apply your changes:

       ```bash
       $ tctl create -f saml.yaml
       ```

    4. Sign out of the Teleport cluster and sign in again to assume the new role.
  </Tab>

  <Tab title="OIDC">
    1. Retrieve your `oidc`  configuration resource:

       ```bash
       $ tctl get oidc/myoidc --with-secrets > oidc.yaml
       ```

       Note that the `--with-secrets` flag adds the value of `spec.signing_key_pair.private_key`
       to the `oidc.yaml` file. Because this key contains a sensitive value, you should remove the
       oidc.yaml file immediately after updating the resource.

    2. Edit `oidc.yaml`, adding `access-plugin-impersonator` to the `claims_to_roles` section.

       The claim you should map to this role depends on how you have designed your organization's
       role-based access controls (RBAC). However, the group must include your user account and
       should be the smallest group possible within your organization.

       Here is an example:

       ```diff
         claims_to_roles:
           - name: "groups"
             value: "my-group"
             roles:
               - access
       +       - access-plugin-impersonator
       ```

    3. Apply your changes:

       ```bash
       $ tctl create -f oidc.yaml
       ```

    4. Sign out of the Teleport cluster and sign in again to assume the new role.
  </Tab>
</Tabs>

You will now be able to generate signed certificates for the `access-plugin`
role and user.

### Export the access-plugin identity files

Like all Teleport users, `access-plugin` needs signed credentials in order to
connect to your Teleport cluster. You will use the `tctl auth sign` command to
request these credentials.

The following `tctl auth sign` command impersonates the `access-plugin` user,
generates signed credentials, and writes an identity file to the local
directory:

```bash
$ tctl auth sign --user=access-plugin --out=identity
```

The plugin connects to the Teleport Auth Service's gRPC endpoint over TLS.

The identity file, `identity`, includes both TLS and SSH credentials. The
plugin uses the SSH credentials to connect to the Proxy Service, which
establishes a reverse tunnel connection to the Auth Service. The plugin
uses this reverse tunnel, along with your TLS credentials, to connect to the
Auth Service's gRPC endpoint.

<Accordion title="Certificate Lifetime">
  By default, `tctl auth sign` produces certificates with a relatively short
  lifetime. For production deployments, we suggest using [Machine
  ID](/docs/machine-id/introduction) to programmatically issue and renew
  certificates for your plugin. See our Machine ID [getting started
  guide](/docs/machine-id/getting-started) to learn more.

  Note that you cannot issue certificates that are valid longer than your existing credentials.
  For example, to issue certificates with a 1000-hour TTL, you must be logged in with a session that is
  valid for at least 1000 hours. This means your user must have a role allowing
  a `max_session_ttl` of at least 1000 hours (60000 minutes), and you must specify a `--ttl`
  when logging in:

  ```bash
  $ tsh login --proxy=teleport.example.com --ttl=60060
  ```
</Accordion>

If you are running the plugin on a Linux server, create a data directory
to hold certificate files for the plugin:

```bash
$ sudo mkdir -p /var/lib/teleport/api-credentials
$ sudo mv identity /var/lib/teleport/plugins/api-credentials
```

If you are running the plugin on Kubernetes, Create a Kubernetes secret
that contains the Teleport identity file:

```bash
$ kubectl -n teleport create secret generic --from-file=identity plugin-identity
```

Once the Teleport credentials expire, you will need to renew them by running the
`tctl auth sign` command again.

We'll reference the exported file(s) later when configuring the plugin.

### Install the plugin

<Tabs>
  <Tab title="Download">
    ```bash
    $ curl -L https://get.gravitational.com/teleport-access-mattermost-v15.0.2-linux-amd64-bin.tar.gz
    $ tar -xzf teleport-access-mattermost-v15.0.2-linux-amd64-bin.tar.gz
    $ cd teleport-access-mattermost
    $ ./install
    ```
  </Tab>

  <Tab title="From Source">
    To install from source you need `git` and `go >= 1.21` installed.

    ```bash
    # Checkout teleport-plugins
    $ git clone https://github.com/gravitational/teleport-plugins.git
    $ cd teleport-plugins/access/mattermost
    $ make
    ```
  </Tab>
</Tabs>

```bash
$ teleport-mattermost configure > /etc/teleport-mattermost.toml
```

Update the config with the Teleport address, Mattermost URL, and a bot token:

```yaml
# example mattermost configuration TOML file
[teleport]
auth_server = "myinstance.teleport.sh:443"                   # Teleport Cloud proxy HTTPS address
identity = "/var/lib/teleport/plugins/mattermost/identity"   # Identity file path
refresh_identity = true                                      # Refresh identity file on a periodic basis.

[mattermost]
url = "https://mattermost.example.com" # Mattermost Server URL
team = "team-name"                     # Mattermost team in which the channel resides.
channel = "channel-name"               # Mattermost Channel name to post requests to
token = "api-token"                    # Mattermost Bot OAuth token
secret = "signing-secret-value"        # Mattermost API signing Secret

[http]
public_addr = "example.com" # URL on which callback server is accessible externally, e.g. [https://]teleport-mattermost.example.com
# listen_addr = ":8081" # Network address in format [addr]:port on which callback server listens, e.g. 0.0.0.0:443
https_key_file = "/var/lib/teleport/plugins/mattermost/server.key"  # TLS private key
https_cert_file = "/var/lib/teleport/plugins/mattermost/server.crt" # TLS certificate

[log]
output = "stderr" # Logger output. Could be "stdout", "stderr" or "/var/lib/teleport/mattermost.log"
severity = "INFO" # Logger severity. Could be "INFO", "ERROR", "DEBUG" or "WARN".

```

## Step 2/3. Configure dual authorization

In this section, we will use an example to show you how to require dual
authorization for a user to assume a role.

### Require dual authorization for a role

Alice and Ivan are reviewers. They can approve requests for assuming role
`dbadmin`. Bob is a DevOps engineer and can assume the `dbadmin` role if two members
of the `reviewer` role approve the request.

Create the following `dbadmin`, `dbreviewer` and `devops` roles:

```yaml
kind: role
version: v5
metadata:
  name: dbreviewer
spec:
  allow:
    review_requests:
      roles: ['dbadmin']
---
kind: role
version: v5
metadata:
  name: devops
spec:
  allow:
    request:
      roles: ['dbadmin']
      thresholds:
        - approve: 2
          deny: 1
---
kind: role
version: v5
metadata:
  name: dbadmin
spec:
  allow:
    logins: ['root']
    node_labels:
      'env': 'prod'
      'type': 'db'
```

The commands below create the local users Bob, Alice, and Ivan.

```bash
$ tctl users add bob@example.com --roles=devops
$ tctl users add alice@example.com --roles=dbreviewer
$ tctl users add ivan@example.com --roles=dbreviewer
```

### Create an Access Request

Bob does not have a role `dbadmin` assigned to him, but can create an Access Request for it.

Bob can create an Access Request for the `dbadmin` role in the Web UI or CLI:

<Tabs>
  <Tab title="Web UI">
        <img src="/assets/teleport-4-bob-request-62329758c7.png" alt="Mattermost-Request" width="2456" height="1234" />
  </Tab>

  <Tab title="Terminal">
    ```bash
    # Bob has to set valid emails of Alice and Ivan matching in Mattermost.
    $ tsh request create --roles=dbadmin --reviewers=alice@example.com,ivan@example.com
    ```
  </Tab>
</Tabs>

Chatbot will notify both Alice and Ivan:

<img src="/assets/mattermost-5-request-36237d0c25.png" alt="Mattermost-Request" width="1940" height="626" />

Alice and Ivan can review and approve request using Web UI or CLI:

<Tabs>
  <Tab title="Web UI">
        <img src="/assets/teleport-6-ivan-approve-2256c804e3.png" alt="Teleport-Approve" width="2408" height="1740" />
  </Tab>

  <Tab title="CLI">
    ```bash
    $ tsh request list

    # ID                                   User             Roles   Created (UTC)       Status
    # ------------------------------------ ---------------  ------- ------------------- -------
    # 9c721e54-b049-4ef8-a7f6-c777aa066764 bob@example.com  dbadmin 03 Apr 21 03:58 UTC PENDING

    $ tsh request review --approve --reason="hello" 9c721e54-b049-4ef8-a7f6-c777aa066764
    # Successfully submitted review.  Request state: APPROVED
    ```
  </Tab>
</Tabs>

If Bob has created a request using CLI, he will assume it once it has been approved.
Bob can also assume granted Access Request roles using Web UI:

<img src="/assets/teleport-7-bob-assume-147c22598b.png" alt="Teleport Assume" width="2432" height="1134" />

## Troubleshooting

### Certificate errors in self-hosted deployments

You may be getting certificate errors if Teleport's Auth Service is missing an address in the server certificate:

```txt
authentication handshake failed: x509: cannot validate certificate for 127.0.0.1 because it doesn't contain any IP SANs
```

```txt
x509: certificate is valid for,*.teleport.cluster.local, teleport.cluster.local, not example.com
```

To fix the problem, update the Auth Service with a public address, and restart Teleport:

```yaml
auth_service:
  public_addr: ['localhost:3025', 'example.com:3025']
```
